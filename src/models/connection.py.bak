from PyQt5.QtWidgets import QGraphicsLineItem, QGraphicsPathItem, QGraphicsTextItem, QGraphicsItem, QMenu, QAction
from PyQt5.QtGui import QPen, QColor, QPainterPath, QFont, QBrush, QPainterPathStroker
from PyQt5.QtCore import Qt, QPointF, pyqtSignal, QObject, QRectF
import uuid
from constants import ConnectionTypes
import logging

class ConnectionSignals(QObject):
    """Signals for connection events."""
    selected = pyqtSignal(object)  # connection
    deleted = pyqtSignal(object)   # connection
    updated = pyqtSignal(object)   # connection

class EditableTextItem(QGraphicsTextItem):
    """A text item that can be edited and sends signals when editing finishes."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setTextInteractionFlags(Qt.TextEditorInteraction)
        self.setFlag(QGraphicsItem.ItemIsFocusable, True)
        self.editing = False
        
        # Background appearance
        self.background_color = QColor(255, 255, 255, 220)  # Slightly transparent white
        self.background_padding = 4  # Padding around text
        
    def paint(self, painter, option, widget):
        """Paint a background rect behind the text."""
        # Draw background rectangle
        painter.save()
        painter.setBrush(self.background_color)
        painter.setPen(Qt.NoPen)  # No border for the background
        
        # Get text rect with padding
        rect = self.boundingRect()
        bg_rect = rect.adjusted(
            -self.background_padding, 
            -self.background_padding, 
            self.background_padding, 
            self.background_padding
        )
        
        # Draw rounded rectangle
        painter.drawRoundedRect(bg_rect, 3, 3)
        painter.restore()
        
        # Draw the text
        super().paint(painter, option, widget)
    
    # Cache the bounding rect for more efficient updates    
    def boundingRect(self):
        rect = super().boundingRect()
        # Include the background padding in the bounding rect
        return rect.adjusted(
            -self.background_padding, 
            -self.background_padding, 
            self.background_padding, 
            self.background_padding
        )
        
    def focusOutEvent(self, event):
        """Finish editing when focus is lost."""
        self.editing = False
        if self.parentItem() and hasattr(self.parentItem(), 'on_label_edited'):
            self.parentItem().on_label_edited(self.toPlainText())
        super().focusOutEvent(event)
        
    def keyPressEvent(self, event):
        """Handle Enter key to finish editing."""
        if event.key() == Qt.Key_Return or event.key() == Qt.Key_Enter:
            self.clearFocus()
            event.accept()
        else:
            super().keyPressEvent(event)

class Connection(QGraphicsPathItem):
    """Represents a connection between two devices in the topology."""
    
    # Routing styles
    STYLE_STRAIGHT = 0
    STYLE_ORTHOGONAL = 1
    STYLE_CURVED = 2
    
    # Path update modes
    UPDATE_BOTH_ENDS = 0
    UPDATE_SOURCE = 1
    UPDATE_TARGET = 2
    
    def __init__(self, source_device, target_device, source_port=None, target_port=None):
        """Initialize a connection between two devices."""
        super().__init__()
        
        # Basic setup
        self.logger = logging.getLogger(__name__)
        self.id = str(uuid.uuid4())
        self.source_device = source_device
        self.target_device = target_device
        
        # Debug mode
        self.debug_selection = False
        
        # Initialize label immediately to avoid NoneType errors
        self.label = None
        
        self.logger.info(f"Creating connection between {source_device.name} and {target_device.name}")
        
        # Add to devices' connections list
        source_device.add_connection(self)
        target_device.add_connection(self)
        
        # Port positions
        self.source_port = source_port or source_device.get_nearest_port(target_device.get_center_position())
        self.target_port = target_port or target_device.get_nearest_port(source_device.get_center_position())
        self._source_port = self.source_port
        self._target_port = self.target_port
        
        # Store raw device positions
        self.source_pos = source_device.scenePos()
        self.target_pos = target_device.scenePos()
        
        # Visual properties
        self._label_text = "Link"  # Default label
        self.connection_type = "ethernet"  # Default type
        self.bandwidth = "1G"  # Default bandwidth
        self.latency = "0ms"  # Default latency
        
        # Add this properties dictionary for storing connection properties
        self.properties = {
            "Bandwidth": self.bandwidth,
            "Latency": self.latency,
            "Label": self._label_text
        }
        
        # Style properties
        self._line_width = 1  # Thinner visual lines
        self.line_width = 1
        self.line_color = QColor(70, 70, 70)
        self.line_style = Qt.SolidLine
        self._base_color = QColor(70, 70, 70)  # Default dark gray
        self._hover_color = QColor(0, 120, 215)  # Default bright blue
        self.selected_color = QColor(255, 140, 0)  # Orange
        self._text_color = QColor(40, 40, 40)  # Near black
        self._routing_style = self.STYLE_ORTHOGONAL  # Changed default to orthogonal
        self.routing_style = self.STYLE_ORTHOGONAL  # Changed default to orthogonal
        
        # Track state
        self.is_selected = False
        self.is_hover = False
        self._was_selected = False
        
        # Control points for orthogonal routing
        self.control_points = []
        self.dragging_control_point = None
        self.control_point_radius = 4
        
        # Create signals object
        self.signals = ConnectionSignals()
        
        # Configure selectable behavior
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setFlag(QGraphicsItem.ItemIsFocusable, True)
        self.setAcceptedMouseButtons(Qt.LeftButton | Qt.RightButton)
        self.setAcceptHoverEvents(True)
        
        # Set Z-value
        self.setZValue(-1)
        
        # Create the path
        self.update_path()
        
        # Now create the label
        self.create_label()
        
        # Setup listeners for device movement
        if hasattr(source_device, 'signals') and hasattr(source_device.signals, 'moved'):
            source_device.signals.moved.connect(self._handle_device_moved)
        
        if hasattr(target_device, 'signals') and hasattr(target_device.signals, 'moved'):
            target_device.signals.moved.connect(self._handle_device_moved)

    @property
    def label_text(self):
        """Get the label text."""
        return self._label_text
    
    @label_text.setter
    def label_text(self, value):
        """Set the label text and update the label."""
        # Ensure the value isn't a QPointF object
        if isinstance(value, QPointF):
            self.logger.warning(f"Attempted to set label_text to QPointF: {value}")
            return
            
        self._label_text = value
        
        # Update the label if it exists
        if self.label:
            self.label.setPlainText(self._label_text)
            self._update_label_position()
    
    def create_label(self):
        """Create or update the connection label."""
        if not self.label:
            self.label = QGraphicsTextItem(self)
            
            # Style the label
            self.label.setDefaultTextColor(self._text_color)
            font = QFont()
            font.setPointSize(8)
            self.label.setFont(font)
        
        # Set the text - safely
        if hasattr(self, '_label_text') and self._label_text and not isinstance(self._label_text, QPointF):
            self.label.setPlainText(self._label_text)
        else:
            # Default label
            self.label.setPlainText("Link")
        
        # Position the label
        self._update_label_position()
    
    def _connect_to_device_changes(self):
        """Connect to device signals to update when devices move."""
        if self.source_device and hasattr(self.source_device, 'signals'):
            if hasattr(self.source_device.signals, 'moved'):
                self.source_device.signals.moved.connect(self._on_device_moved)
        
        if self.target_device and hasattr(self.target_device, 'signals'):
            if hasattr(self.target_device.signals, 'moved'):
                self.target_device.signals.moved.connect(self._on_device_moved)

    def _on_device_moved(self, device):
        """Handle device movement by updating the connection path."""
        # Capture the old bounding rect before update
        old_rect = self.boundingRect()
        if self.label:
            old_rect = old_rect.united(
                self.label.boundingRect().adjusted(
                    -self.label.background_padding*2,
                    -self.label.background_padding*2,
                    self.label.background_padding*2,
                    self.label.background_padding*2
                ).translated(self.label.pos())
            )
        
        # Update the path
        self.update_path()
        
        # Make sure we update the scene with both old and new areas
        if self.scene():
            scene_rect = self.mapToScene(old_rect).boundingRect().united(
                self.mapToScene(self.boundingRect()).boundingRect()
            )
            # Add some margin
            scene_rect.adjust(-5, -5, 5, 5)
            self.scene().update(scene_rect)
    
    def _find_best_port(self, from_device, to_device):
        """Find the best connection port on from_device facing to_device."""
        # Get center of target device
        if hasattr(to_device, 'get_center_position'):
            target_center = to_device.get_center_position()
        else:
            target_center = to_device.scenePos()
            
        # Find nearest port on source device
        if hasattr(from_device, 'get_nearest_port'):
            return from_device.get_nearest_port(target_center)
            
        # Fall back to device position
        return from_device.scenePos()
    
    def update_path(self):
        """Update the connection path based on current device positions."""
        try:
            # Store current label text and selection state
            current_label_text = None
            if hasattr(self, 'label') and self.label:
                current_label_text = self.label.toPlainText()
            elif hasattr(self, '_label_text'):
                current_label_text = self._label_text
            
            was_selected = self.isSelected()
            
            # Re-calculate ports in case devices moved
            if hasattr(self, '_find_best_port'):
                self._source_port = self._find_best_port(self.source_device, self.target_device)
                self._target_port = self._find_best_port(self.target_device, self.source_device)
            
            # Store state of control points for orthogonal path
            dragging_point = self.dragging_control_point
            old_control_points = self.control_points.copy() if self.control_points else []
            
            # Get the old path bounds for updating
            old_rect = self.sceneBoundingRect().adjusted(-100, -100, 100, 100)
            
            # Notify Qt that our geometry will change
            self.prepareGeometryChange()
            
            # Create a fresh path
            path = QPainterPath()
            path.moveTo(self._source_port)
            
            if self.routing_style == self.STYLE_STRAIGHT:
                # Simple straight line
                path.lineTo(self._target_port)
                # Clear any control points
                self.control_points = []
                self.dragging_control_point = None
                
            elif self.routing_style == self.STYLE_ORTHOGONAL:
                # Right-angle connections (Manhattan routing)
                sx, sy = self._source_port.x(), self._source_port.y()
                tx, ty = self._target_port.x(), self._target_port.y()
                
                # If we don't have control points or they were reset, initialize them
                if not self.control_points or len(self.control_points) != 2:
                    dx, dy = tx - sx, ty - sy
                    
                    # Decide on horizontal-first or vertical-first routing
                    if abs(dx) > abs(dy):
                        # Horizontal dominant - go horizontally first
                        middle_x = sx + dx/2
                        self.control_points = [
                            QPointF(middle_x, sy),  # First point - horizontal from source
                            QPointF(middle_x, ty)   # Second point - vertical to target
                        ]
                    else:
                        # Vertical dominant - go vertically first
                        middle_y = sy + dy/2
                        self.control_points = [
                            QPointF(sx, middle_y),  # First point - vertical from source
                            QPointF(tx, middle_y)   # Second point - horizontal to target
                        ]
                else:
                    # If ports moved, recalculate control points to maintain orthogonality
                    if not dragging_point:  # Only recalculate if not actively dragging
                        # Get old control points
                        if len(old_control_points) == 2:
                            cp1, cp2 = old_control_points
                            # Determine if horizontal-first or vertical-first
                            horizontal_first = abs(cp1.x() - old_control_points[0].x()) < abs(cp1.y() - old_control_points[0].y())
                            
                            # Update control points while maintaining orthogonality
                            if horizontal_first:
                                # Maintain the same x position for the bend
                                middle_x = cp1.x()
                                self.control_points = [
                                    QPointF(middle_x, sy),  # First point - kept x, updated y
                                    QPointF(middle_x, ty)   # Second point - kept x, updated y
                                ]
                            else:
                                # Maintain the same y position for the bend
                                middle_y = cp1.y()
                                self.control_points = [
                                    QPointF(sx, middle_y),  # First point - kept y, updated x
                                    QPointF(tx, middle_y)   # Second point - kept y, updated x
                                ]
            
                # Draw path through control points
                cp1, cp2 = self.control_points
                path.lineTo(cp1)
                path.lineTo(cp2)
                path.lineTo(self._target_port)
                
            elif self.routing_style == self.STYLE_CURVED:
                # Bezier curve
                sx, sy = self._source_port.x(), self._source_port.y()
                tx, ty = self._target_port.x(), self._target_port.y()
                
                # Control points at 1/3 and 2/3 of the path
                dx, dy = tx - sx, ty - sy
                cp1 = QPointF(sx + dx/3, sy)
                cp2 = QPointF(tx - dx/3, ty)
                
                path.cubicTo(cp1, cp2, self._target_port)
                # Clear any orthogonal control points
                self.control_points = []
                self.dragging_control_point = None
            
            # Completely replace the path
            self.setPath(path)
            
            # Restore selection state
            self.setSelected(was_selected)
            
            # Ensure we preserve the label
            if not hasattr(self, 'label') or not self.label:
                self.create_label()
            
            # Always set the label text to preserve it
            if current_label_text:
                self._label_text = current_label_text  # Store in attribute
                self.label.setPlainText(current_label_text)  # Update the visual label
            
            # Update label position
            self._update_label_position()
            
            # Force a full update of the entire affected area
            if self.scene():
                new_rect = self.sceneBoundingRect().adjusted(-100, -100, 100, 100)
                update_rect = old_rect.united(new_rect)
                
                # Invalidate scene caches and force redraw
                self.scene().invalidate(update_rect, QGraphicsScene.AllLayers)
                self.scene().update(update_rect)
                
                # Force update on all views for clean redraw
                for view in self.scene().views():
                    view.viewport().update()
            
        except Exception as e:
            self.logger.error(f"Error updating path: {str(e)}")
            import traceback
            self.logger.error(traceback.format_exc())

    def _update_label_position(self):
        """Place label at center of connection."""
        try:
            # First check if label exists
            if not hasattr(self, 'label') or self.label is None:
                return
                
            # Get path center point - use safe access to path
            path = self.path()
            if path and not path.isEmpty():
                # Calculate center point of the path
                center_point = path.pointAtPercent(0.5)
                
                # Position the label precisely at the center, accounting for label size
                label_width = self.label.boundingRect().width()
                label_height = self.label.boundingRect().height()
                
                # Position label at center point, offset by half its dimensions
                self.label.setPos(
                    center_point.x() - label_width/2,
                    center_point.y() - label_height/2
                )
            else:
                # Fallback if no valid path exists
                if hasattr(self, '_source_port') and hasattr(self, '_target_port'):
                    # Use midpoint between source and target ports
                    mid_x = (self._source_port.x() + self._target_port.x()) / 2
                    mid_y = (self._source_port.y() + self._target_port.y()) / 2
                    
                    # Position label at this midpoint
                    label_width = self.label.boundingRect().width()
                    label_height = self.label.boundingRect().height()
                    
                    self.label.setPos(
                        mid_x - label_width/2,
                        mid_y - label_height/2
                    )
        except Exception as e:
            self.logger.error(f"Error updating label position: {str(e)}")
    
    def set_style_for_type(self, connection_type):
        """Set the visual style based on the connection type."""
        # Import constants if needed (in case this method is called directly)
        from constants import ConnectionTypes
        
        # Default style
        style = {
            'color': QColor(30, 30, 30),
            'style': Qt.SolidLine,
            'width': 2
        }
        
        # Style based on connection type
        if connection_type == ConnectionTypes.ETHERNET:
            style = {'color': QColor(0, 0, 0), 'style': Qt.SolidLine, 'width': 2}
        elif connection_type == ConnectionTypes.SERIAL:
            style = {'color': QColor(0, 0, 255), 'style': Qt.DashLine, 'width': 1.5}
        elif connection_type == ConnectionTypes.FIBER:
            style = {'color': QColor(0, 128, 0), 'style': Qt.SolidLine, 'width': 3}
        elif connection_type == ConnectionTypes.WIRELESS:
            style = {'color': QColor(128, 0, 128), 'style': Qt.DotLine, 'width': 1.5}
        elif connection_type == ConnectionTypes.GIGABIT_ETHERNET:
            style = {'color': QColor(50, 50, 50), 'style': Qt.SolidLine, 'width': 2.5}
        elif connection_type == ConnectionTypes.TEN_GIGABIT_ETHERNET:
            style = {'color': QColor(0, 100, 200), 'style': Qt.SolidLine, 'width': 3}
        elif connection_type == ConnectionTypes.FORTY_GIGABIT_ETHERNET:
            style = {'color': QColor(0, 150, 200), 'style': Qt.SolidLine, 'width': 3.5}
        elif connection_type == ConnectionTypes.HUNDRED_GIGABIT_ETHERNET:
            style = {'color': QColor(0, 200, 200), 'style': Qt.SolidLine, 'width': 4}
        elif connection_type == ConnectionTypes.FIBER_CHANNEL:
            style = {'color': QColor(200, 100, 0), 'style': Qt.SolidLine, 'width': 3}
        elif connection_type == ConnectionTypes.MPLS:
            style = {'color': QColor(100, 0, 100), 'style': Qt.DashDotLine, 'width': 2.5}
        elif connection_type == ConnectionTypes.POINT_TO_POINT:
            style = {'color': QColor(0, 0, 100), 'style': Qt.SolidLine, 'width': 2}
        elif connection_type == ConnectionTypes.VPN:
            style = {'color': QColor(0, 100, 0), 'style': Qt.DashDotDotLine, 'width': 2}
        elif connection_type == ConnectionTypes.SDWAN:
            style = {'color': QColor(0, 128, 128), 'style': Qt.DashDotLine, 'width': 2.5}
        elif connection_type == ConnectionTypes.SATELLITE:
            style = {'color': QColor(128, 0, 0), 'style': Qt.DotLine, 'width': 2}
        elif connection_type == ConnectionTypes.MICROWAVE:
            style = {'color': QColor(200, 0, 0), 'style': Qt.DotLine, 'width': 1.5}
        elif connection_type == ConnectionTypes.BLUETOOTH:
            style = {'color': QColor(0, 0, 200), 'style': Qt.DashDotLine, 'width': 1.5}
        elif connection_type == ConnectionTypes.CUSTOM:
            style = {'color': QColor(50, 50, 50), 'style': Qt.SolidLine, 'width': 2}
        
        # Store current connection type
        self.connection_type = connection_type
        
        # Apply style
        self.line_color = style['color']
        self.line_style = style['style']
        self.line_width = style['width']
        self._apply_style()
        
        # Update label text to match connection type if needed
        if hasattr(self, 'label_text'):
            # Import here to avoid circular import
            from constants import ConnectionTypes
            display_name = ConnectionTypes.DISPLAY_NAMES.get(connection_type, "Link")
            self.label_text = display_name
    
    def _apply_style(self):
        """Apply the current style settings."""
        pen = QPen()
        
        # Use selected color if selected
        if self.isSelected():
            pen.setColor(self.selected_color)
        else:
            pen.setColor(self.line_color)
        
        pen.setWidthF(self.line_width)
        pen.setStyle(self.line_style)
        pen.setCapStyle(Qt.RoundCap)
        
        self.setPen(pen)
    
    def create_label(self):
        """Create a text label for the connection."""
        if not self.label:
            self.label = EditableTextItem(self)
            
            # Use the stored label text, not a default value
            self.label.setPlainText(self.label_text)
            
            # Make the label more visible with a better background
            self.label.setDefaultTextColor(QColor(0, 0, 0))
            font = QFont()
            font.setBold(True)
            self.label.setFont(font)
            
            # Set background color with higher opacity for better visibility
            self.label.background_color = QColor(255, 255, 255, 220)
            self.label.background_padding = 5  # More padding around text
            
            # Set Z-value to be above the connection line
            self.label.setZValue(self.zValue() + 1)
            
            # Update position
            self._update_label_position()
            
            print(f"Created label with text: '{self.label_text}'")
    
    def on_label_edited(self, new_text):
        """Called when the label editing is finished."""
        if new_text != self.label_text:
            self.label_text = new_text
            self._update_label_position()  # Recenter based on new text size
            
            # If there's a signal for connection changes, emit it
            if hasattr(self.signals, 'changed'):
                self.signals.changed.emit(self)
    
    def set_routing_style(self, style):
        """Set the routing style (straight, orthogonal, curved)."""
        self.logger.debug(f"Setting routing style to {style} (was {self.routing_style})")
        
        # Convert string styles to integer constants for internal use
        if isinstance(style, str):
            style_map = {
                "direct": self.STYLE_STRAIGHT,
                "straight": self.STYLE_STRAIGHT,
                "orthogonal": self.STYLE_ORTHOGONAL,
                "curved": self.STYLE_CURVED
            }
            if style.lower() in style_map:
                style = style_map[style.lower()]
        
        # Check if style is a valid integer value
        if style not in (self.STYLE_STRAIGHT, self.STYLE_ORTHOGONAL, self.STYLE_CURVED):
            self.logger.warning(f"Invalid routing style: {style}, defaulting to ORTHOGONAL")
            style = self.STYLE_ORTHOGONAL
        
        # Only update if style actually changed
        if style != self.routing_style:
            # Store old path bounding rect for update
            old_rect = self.sceneBoundingRect()
            
            # Clear control points when changing styles
            self.control_points = []
            self.dragging_control_point = None
            
            # Update the style
            self.routing_style = style
            self._routing_style = style
            
            # Notify Qt that our geometry will change
            self.prepareGeometryChange()
            
            # Completely refresh the path
            self.update_path()
            
            # Force a comprehensive scene update
            if self.scene():
                # Get new bounding rect
                new_rect = self.sceneBoundingRect()
                
                # Create update rect that includes both old and new areas
                update_rect = old_rect.united(new_rect).adjusted(-50, -50, 50, 50)
                self.scene().update(update_rect)
                
                # Force update on all views
                for view in self.scene().views():
                    view.viewport().update()
    
    def paint(self, painter, option, widget=None):
        """Draw the connection and control points when selected."""
        # Make sure our style is always correctly applied
        if self.isSelected() != self._was_selected:
            self._was_selected = self.isSelected()
            self._apply_style()
        
        # Draw the connection path
        super().paint(painter, option, widget)
        
        # Only draw control points when selected and in orthogonal mode
        if self.isSelected() and self.routing_style == self.STYLE_ORTHOGONAL and self.control_points and len(self.control_points) == 2:
            painter.save()
            
            # Draw control points with a more visible appearance
            control_point_radius = 8  # Increased size for better visibility
            
            # Draw white-filled circle with black border
            painter.setPen(QPen(Qt.black, 2))
            painter.setBrush(QBrush(Qt.white))
            
            # Draw each control point
            for cp in self.control_points:
                # Draw the main control point
                painter.drawEllipse(cp, control_point_radius, control_point_radius)
                
                # Draw a smaller highlight in the center for better visual feedback
                painter.setPen(Qt.NoPen)
                painter.setBrush(QBrush(QColor(0, 120, 215)))  # Highlight blue
                painter.drawEllipse(cp, control_point_radius/2, control_point_radius/2)
            
            painter.restore()

    def mousePressEvent(self, event):
        """Handle mouse press, detecting control point selection."""
        # Only process control points when in orthogonal mode and we have control points
        if self.routing_style == self.STYLE_ORTHOGONAL and self.control_points and len(self.control_points) == 2:
            # Get mouse position in item coordinates
            pos = event.pos()
            
            # Check if we clicked on a control point
            for i, cp in enumerate(self.control_points):
                if (pos - cp).manhattanLength() < 20:  # Large hit area (20px)
                    self.dragging_control_point = i
                    self.setSelected(True)  # Ensure item is selected when dragging starts
                    event.accept()
                    return
        
        # Fall back to standard handling
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        """Handle control point dragging with orthogonal constraints."""
        # Only process if we're dragging a control point
        if self.dragging_control_point is not None and len(self.control_points) == 2:
            # Signal that geometry will change before making any modifications
            self.prepareGeometryChange()
            
            # Calculate the update area that needs to be cleaned - make it very large
            old_rect = self.sceneBoundingRect().adjusted(-200, -200, 200, 200)
            
            # Get mouse position and port positions
            pos = event.pos()
            source_port = self._source_port
            target_port = self._target_port
            
            # Determine if we're in horizontal-first or vertical-first routing
            cp1 = self.control_points[0]
            horizontal_first = abs(cp1.x() - source_port.x()) > abs(cp1.y() - source_port.y())
            
            # Update control points based on drag direction
            if self.dragging_control_point == 0:  # First control point
                if horizontal_first:
                    # In horizontal-first mode, first point moves horizontally
                    new_x = pos.x()
                    self.control_points[0] = QPointF(new_x, source_port.y())
                    self.control_points[1] = QPointF(new_x, target_port.y())
                else:
                    # In vertical-first mode, first point moves vertically
                    new_y = pos.y()
                    self.control_points[0] = QPointF(source_port.x(), new_y)
                    self.control_points[1] = QPointF(target_port.x(), new_y)
            else:  # Second control point
                if horizontal_first:
                    # In horizontal-first mode, second point moves vertically
                    new_y = pos.y()
                    # Keep x coordinate from first control point
                    self.control_points[1] = QPointF(self.control_points[0].x(), new_y)
                else:
                    # In vertical-first mode, second point moves horizontally
                    new_x = pos.x()
                    # Keep y coordinate from first control point
                    self.control_points[1] = QPointF(new_x, self.control_points[0].y())
            
            # Completely recreate the path to remove any artifacts
            path = QPainterPath()
            path.moveTo(source_port)
            path.lineTo(self.control_points[0])
            path.lineTo(self.control_points[1])
            path.lineTo(target_port)
            
            # Set the new path
            self.setPath(path)
            
            # Update label position
            self._update_label_position()
            
            # Force thorough scene update to clean up artifacts
            if self.scene():
                # Calculate new rect and combine with old for complete cleanup
                new_rect = self.sceneBoundingRect().adjusted(-200, -200, 200, 200)
                update_rect = old_rect.united(new_rect)
                
                # Both invalidate and update to ensure complete redraw
                self.scene().invalidate(update_rect, QGraphicsScene.AllLayers)
                self.scene().update(update_rect)
                
                # Update all views
                for view in self.scene().views():
                    view.viewport().update()
            
            event.accept()
            return
        
        # Fall back to standard handling
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Complete control point dragging."""
        if self.dragging_control_point is not None:
            # Signal that geometry is changing
            self.prepareGeometryChange()
            
            # End the dragging operation
            self.dragging_control_point = None
            
            # Force a massive update area to clean everything up
            if self.scene():
                # Use an extra large area to catch any artifacts
                rect = self.sceneBoundingRect().adjusted(-300, -300, 300, 300)
                
                # Force complete scene redraw
                self.scene().invalidate(rect, QGraphicsScene.AllLayers)
                self.scene().update(rect)
                
                # Force update all views
                for view in self.scene().views():
                    view.viewport().update()
                    view.update()  # Update the view itself too
            
            # Ensure we emit an updated signal
            self.signals.updated.emit(self)
            
            event.accept()
            return
        
        # Fall back to standard handling
        super().mouseReleaseEvent(event)

    def shape(self):
        """Custom shape to include control points in hit testing."""
        # Create a base path from the connection line
        path = super().shape()
        
        # Add control points to the shape when in orthogonal mode
        # NOTE: Not limiting it to only selected state allows initial clicking
        if self.routing_style == self.STYLE_ORTHOGONAL and self.control_points:
            # Very large hit radius for easier selection (25px)
            hit_radius = 25  
            
            # Add each control point to the clickable area
            for cp in self.control_points:
                cp_path = QPainterPath()
                cp_path.addEllipse(cp, hit_radius, hit_radius)
                path.addPath(cp_path)
        
        return path

    def itemChange(self, change, value):
        """Handle item changes like selection."""
        if change == QGraphicsItem.ItemSelectedChange:
            # Log selection changes
            if self.debug_selection:
                self.logger.info(f"Connection {self.id} selection changing to: {bool(value)}")
            
            # Emit signal when selection changes
            if value:
                self.signals.selected.emit(self)
            else:
                self.signals.selected.emit(self)
            
            # Update appearance
            self._apply_style()
        
        # Debug position change
        elif change == QGraphicsItem.ItemPositionHasChanged and self.debug_selection:
            self.logger.debug(f"Connection {self.id} position changed")
        
        return super().itemChange(change, value)
    
    def hoverEnterEvent(self, event):
        """Handle hover enter event."""
        if self.debug_selection:
            self.logger.info(f"Hover enter on connection {self.id}")
        
        self.is_hover = True
        # Highlight connection on hover
        self.setPen(QPen(self.selected_color, self.line_width + 1, self.line_style))
        super().hoverEnterEvent(event)
    
    def hoverLeaveEvent(self, event):
        """Handle hover leave event."""
        if self.debug_selection:
            self.logger.info(f"Hover leave on connection {self.id}")
        
        self.is_hover = False
        # Restore original appearance
        self._apply_style()
        super().hoverLeaveEvent(event)
    
    def delete(self):
        """Remove this connection."""
        # Store scene and path for later update
        scene = self.scene()
        path_rect = self.boundingRect()
        scene_path = self.mapToScene(path_rect).boundingRect().adjusted(-20, -20, 20, 20)
        
        # If we have a label, include its area in the update region
        if self.label and self.label.scene():
            label_rect = self.label.sceneBoundingRect()
            scene_path = scene_path.united(label_rect.adjusted(-5, -5, 5, 5))
        
        # Disconnect from devices
        if self.source_device:
            if hasattr(self.source_device, 'remove_connection'):
                self.source_device.remove_connection(self)
        
        if self.target_device:
            if hasattr(self.target_device, 'remove_connection'):
                self.target_device.remove_connection(self)
        
        # Emit signal before removal
        self.signals.deleted.emit(self)
        
        # Remove the label first to avoid dangling references
        if self.label and self.label.scene():
            scene.removeItem(self.label)
        
        # Remove from scene
        if scene:
            scene.removeItem(self)
            
            # Force update the affected area
            scene.update(scene_path)
            
            # Update all connected views
            for view in scene.views():
                view.viewport().update()
    
    def contextMenuEvent(self, event):
        """Show context menu on right-click."""
        menu = QMenu()
        
        # Add "Edit Label" action
        edit_action = QAction("Edit Label", self.scene().views()[0])
        edit_action.triggered.connect(self._start_label_editing)
        menu.addAction(edit_action)
        
        # Add "Show Connection Info" action
        info_action = QAction("Connection Info", self.scene().views()[0])
        info_action.triggered.connect(self._show_connection_info)
        menu.addAction(info_action)
        
        # Add other possible actions
        delete_action = QAction("Delete Connection", self.scene().views()[0])
        delete_action.triggered.connect(self._delete_connection)
        menu.addAction(delete_action)
        
        # Show the menu at the event position
        menu.exec_(event.screenPos())
    
    def _show_connection_info(self):
        """Show a dialog with connection information."""
        from PyQt5.QtWidgets import QMessageBox
        
        # Get connection type display name
        from constants import ConnectionTypes
        conn_type_display = ConnectionTypes.DISPLAY_NAMES.get(
            self.connection_type, 
            "Unknown Connection Type"
        )
        
        # Build info message
        info = f"Connection Type: {conn_type_display}\n"
        info += f"Label: {self.label_text}\n"
        
        if self.bandwidth:
            info += f"Bandwidth: {self.bandwidth}\n"
        if self.latency:
            info += f"Latency: {self.latency}\n"
            
        info += f"Source Device: {self.source_device.name}\n"
        info += f"Target Device: {self.target_device.name}\n"
        
        # Show the info dialog
        QMessageBox.information(
            self.scene().views()[0], 
            "Connection Information",
            info
        )
    
    def _start_label_editing(self):
        """Start editing the connection label."""
        if self.label:
            self.label.editing = True
            self.label.setTextInteractionFlags(Qt.TextEditorInteraction)
            self.label.setFocus()
    
    def _delete_connection(self):
        """Delete this connection."""
        # Disconnect from device signals
        if self.source_device and hasattr(self.source_device, 'signals'):
            if hasattr(self.source_device.signals, 'moved'):
                self.source_device.signals.moved.disconnect(self._on_device_moved)
        
        if self.target_device and hasattr(self.target_device, 'signals'):
            if hasattr(self.target_device.signals, 'moved'):
                self.target_device.signals.moved.disconnect(self._on_device_moved)
        
        # Remove from scene
        if self.scene():
            self.scene().removeItem(self)
            
            # Notify the canvas that a connection was deleted (if signal exists)
            for view in self.scene().views():
                if hasattr(view, 'connection_deleted'):
                    view.connection_deleted.emit(self)

    def _handle_device_moved(self, device):
        """Handle when a device has moved and update the connection accordingly."""
        # Store old bounding rect for update
        old_rect = self.sceneBoundingRect()
        
        # Recalculate ports
        if hasattr(self, '_find_best_port'):
            self._source_port = self._find_best_port(self.source_device, self.target_device)
            self._target_port = self._find_best_port(self.target_device, self.source_device)
        
        # Recalculate control points for orthogonal routing
        if self.routing_style == self.STYLE_ORTHOGONAL:
            self._recalculate_control_points()
        
        # Update the path
        self.update_path()
        
        # Update the scene with both old and new areas
        if self.scene():
            new_rect = self.sceneBoundingRect()
            update_rect = old_rect.united(new_rect).adjusted(-20, -20, 20, 20)
            self.scene().update(update_rect)
            
            # Force update on all views
            for view in self.scene().views():
                view.viewport().update()

    def _recalculate_control_points(self):
        """Recalculate control points to maintain orthogonal angles when devices move."""
        if self.routing_style != self.STYLE_ORTHOGONAL:
            return
            
        # Get current port positions
        sx, sy = self._source_port.x(), self._source_port.y()
        tx, ty = self._target_port.x(), self._target_port.y()
        
        # If we don't have control points, use default routing
        if not self.control_points or len(self.control_points) != 2:
            dx, dy = tx - sx, ty - sy
            if abs(dx) > abs(dy):
                # Horizontal dominant
                middle_x = sx + dx/2
                self.control_points = [
                    QPointF(middle_x, sy),
                    QPointF(middle_x, ty)
                ]
            else:
                # Vertical dominant
                middle_y = sy + dy/2
                self.control_points = [
                    QPointF(sx, middle_y),
                    QPointF(tx, middle_y)
                ]
            return
        
        # Get existing control points
        cp1, cp2 = self.control_points
        
        # Determine if we're using horizontal-first or vertical-first routing
        # by looking at the first control point's orientation from source
        horiz_first = abs(cp1.x() - sx) > abs(cp1.y() - sy)
        
        if horiz_first:
            # Horizontal first routing - maintain x-coordinate of bend
            bend_x = cp1.x()
            
            # Calculate how far the bend is along the x-axis as a percentage
            # This helps maintain the proportional position when devices move
            src_target_x_dist = tx - sx
            if abs(src_target_x_dist) > 0.001:  # Avoid division by zero
                x_percent = (bend_x - sx) / src_target_x_dist
                x_percent = max(0.1, min(0.9, x_percent))  # Keep within reasonable bounds
                new_bend_x = sx + src_target_x_dist * x_percent
            else:
                # Fallback if source and target are vertically aligned
                new_bend_x = sx
            
            # Update control points - horizontal first routing
            self.control_points = [
                QPointF(new_bend_x, sy),  # First point - horizontal from source
                QPointF(new_bend_x, ty)   # Second point - vertical to target
            ]
        else:
            # Vertical first routing - maintain y-coordinate of bend
            bend_y = cp1.y()
            
            # Calculate how far the bend is along the y-axis as a percentage
            src_target_y_dist = ty - sy
            if abs(src_target_y_dist) > 0.001:  # Avoid division by zero
                y_percent = (bend_y - sy) / src_target_y_dist
                y_percent = max(0.1, min(0.9, y_percent))  # Keep within reasonable bounds
                new_bend_y = sy + src_target_y_dist * y_percent
            else:
                # Fallback if source and target are horizontally aligned
                new_bend_y = sy
            
            # Update control points - vertical first routing
            self.control_points = [
                QPointF(sx, new_bend_y),  # First point - vertical from source
                QPointF(tx, new_bend_y)   # Second point - horizontal to target
            ]

    def update_label(self):
        """Update connection label text."""
        if hasattr(self, 'label_item') and self.label_item and hasattr(self, 'label_text'):
            self.label_item.setPlainText(self.label_text)